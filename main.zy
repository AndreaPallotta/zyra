struct User {
  id: Int,
  name: String
}

enum Result {
  Ok(value: Int),
  Err(error: String)
}

export def add(x: Int, y: Int): Int {
  x + y
}

const u: User = User { id: 1, name: "Andre" }
const r1: Result = Ok(42)
const r2: Result = Err("nope")

print("ok u=", u, " r1=", r1, "r2=", r2)

// --- should PASS ---
const a: Int = add(1, 2)
print("a=", a)

const m1: Int = match (r1) {
  Ok(v) => v,
  Err(_e) => 0
}
print("m1=", m1)

// --- should FAIL (uncomment one block at a time) ---

// 1) call-site arg type mismatch (expects Int)
// const badCall: Int = add(true, 2)

// 2) arity mismatch
// const badArity: Int = add(1)

// 3) struct field type mismatch (name expects String)
// const badUser1: User = User { id: 1, name: true }

// 4) struct unknown field
// const badUser2: User = User { id: 1, name: "ok", age: 99 }

// 5) struct update wrong target type
// const badUpd1 = 123 { name: "Zyra" }

// 6) struct update wrong field type
// const badUpd2: User = u { name: false }

// 7) enum payload wrong type (Ok expects Int)
// const badEnum1: Result = Ok("hi")

// 8) enum payload missing
// const badEnum2: Result = Ok()

// 9) match guard must be boolean
// const badGuard: Int = match (r1) {
//   Ok(v) if 1 => v,
//   Err(_e) => 0
// }
